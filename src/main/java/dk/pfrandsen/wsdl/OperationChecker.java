package dk.pfrandsen.wsdl;

import dk.pfrandsen.check.AnalysisInformationCollector;
import dk.pfrandsen.util.Utilities;
import dk.pfrandsen.util.WsdlUtil;
import dk.pfrandsen.util.XQuery;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;

public class OperationChecker {
    public static final String ASSERTION_ID_NAME = "CA15-WSDL-Operation-Name-Validate";

    // prefixes are generated by FindAllOperations.groovy
    private final static String[] knownPrefixes = {"Afbryd", "Afslut", "Anmodning", "Annuller", "Archive", "Dialog",
            "Dokument", "Fejltjek", "Gem", "Get", "Hent", "List", "Modtagelses", "Opdater", "Opret", "Overfoer",
            "Overfoerselsnota", "Rapporter", "Sag", "accept", "accepter", "account", "activate", "add", "afslut",
            "annuller", "archive", "attach", "block", "cache", "calculate", "cancel", "change", "charge", "clone",
            "close", "copy", "count", "create", "custody", "dan", "delete", "deliver", "deregister", "describe",
            "determine", "disburse", "does", "download", "exists", "find", "gem", "get", "hent", "invalidate", "is",
            "laes", "list", "load", "log", "match", "modify", "move", "notification", "notify", "ocap", "opret",
            "order", "payout", "prepare", "process", "publish", "read", "receive", "refresh", "register", "remove",
            "replace", "rollover", "save", "schedule", "search", "send", "set", "split", "start", "stop", "store",
            "terminate", "tilbagefoer", "transfer", "translate", "unmatch", "update", "validate", "valuate",
            "withdraw"};

    public static void checkOperationNames(String wsdl, AnalysisInformationCollector collector) {
        try {
            List<String> portTypes = WsdlUtil.getPortTypes(wsdl);
            for (String portType : portTypes) {
                Path xqPortType = Paths.get("wsdl", "porttype");
                String xqPortTypeOperations = XQuery.runXQuery(xqPortType, "operations.xq", wsdl, portType);
                List<String> operationNames = XQuery.mapResult(xqPortTypeOperations, "name");
                // name must be lower camel case
                for (String operationName : operationNames) {
                    if (!Utilities.isLowerCamelCaseAscii(operationName)) {
                        collector.addError(ASSERTION_ID_NAME, "Operation name must be lower camel case",
                                AnalysisInformationCollector.SEVERITY_LEVEL_MAJOR, "Operation '" + operationName +
                                        "', portType '" + portType + "'");
                    }
                    // name must consist of at least two words (action + object)
                    List<String> nameParts = Utilities.splitOnUppercase(operationName);
                    if (nameParts.size() < 2) {
                        collector.addError(ASSERTION_ID_NAME, "Operation name must contain <action><Object>",
                                AnalysisInformationCollector.SEVERITY_LEVEL_MAJOR, "Operation '" + operationName +
                                        "' in portType '" + portType + "' only has action or object");
                    }
                    // warn if action is not in the set of known prefixes
                    if (!Arrays.asList(knownPrefixes).contains(nameParts.get(0))) {
                        collector.addWarning(ASSERTION_ID_NAME, "Operation <action> is unknown",
                                AnalysisInformationCollector.SEVERITY_LEVEL_MAJOR, "Action '" + nameParts.get(0) +
                                        "' in operation '" + operationName + "' in portType '" + portType +
                                        "' is not in set of previously defined actions");
                    }
                }
            }
        } catch (Exception e) {
            collectException(e, collector, ASSERTION_ID_NAME);
        }
    }

    public static void checkPortTypeAndBinding(String wsdl, AnalysisInformationCollector collector) {
        // portType and binding must have the same operations, and each operation must have the same input, output,
        // and faults (warn if faults are listed in different order)
    }

    private static void collectException(Exception e, AnalysisInformationCollector collector, String assertion) {
        collector.addInfo(assertion, "Exception while checking operations",
                AnalysisInformationCollector.SEVERITY_LEVEL_UNKNOWN, e.getMessage());
    }

}
